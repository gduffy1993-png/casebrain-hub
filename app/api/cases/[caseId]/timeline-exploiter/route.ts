import "server-only";
import { NextRequest, NextResponse } from "next/server";
import { requireAuthContext } from "@/lib/auth";
import { buildCaseContext, guardAnalysis } from "@/lib/case-context";
import { getSupabaseAdminClient } from "@/lib/supabase";
import { normalizePracticeArea } from "@/lib/types/casebrain";

export const runtime = "nodejs";

type TimelineIssue = {
  type: "SUSPICIOUS_GAP" | "INCONSISTENCY" | "MISSING_PERIOD" | "PROCEDURAL_DELAY" | "OTHER";
  description: string;
  attackStrategy: string;
  readyToUseArgument: string;
};

type TimelineExploiter = {
  issues: TimelineIssue[];
  criticalGaps: TimelineIssue[];
  exploitationPlan: string[];
};

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ caseId: string }> }
) {
  try {
    const { userId } = await requireAuthContext();
    const { caseId } = await params;

    const context = await buildCaseContext(caseId, { userId });

    if (!context.case) {
      return NextResponse.json(
        { ok: false, data: null, banner: context.banner, diagnostics: context.diagnostics },
        { status: 404 }
      );
    }

    try {
      guardAnalysis(context);
    } catch (error: any) {
      if (error.name === "AnalysisGateError") {
        return NextResponse.json({
          ok: false,
          data: null,
          banner: error.banner,
          diagnostics: error.diagnostics,
        });
      }
      throw error;
    }

    const supabase = getSupabaseAdminClient();
    const practiceArea = normalizePracticeArea(context.case.practice_area as string | null);

    // Get timeline from case summary
    const { data: summary } = await supabase
      .from("case_analysis")
      .select("analysis_json")
      .eq("case_id", caseId)
      .eq("analysis_type", "case_summary")
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    const summaryData = summary?.analysis_json as any;
    const timeline = summaryData?.timeline || [];

    // Get strategy analysis for gaps
    const { data: strategyAnalysis } = await supabase
      .from("case_analysis")
      .select("analysis_json")
      .eq("case_id", caseId)
      .eq("analysis_type", practiceArea === "criminal" ? "aggressive_defense" : "strategic_overview")
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    const strategyData = strategyAnalysis?.analysis_json as any;

    const issues: TimelineIssue[] = [];

    // Analyze timeline for gaps
    if (timeline.length > 1) {
      for (let i = 0; i < timeline.length - 1; i++) {
        const current = timeline[i];
        const next = timeline[i + 1];
        
        if (current?.date && next?.date) {
          const currentDate = new Date(current.date);
          const nextDate = new Date(next.date);
          const daysDiff = (nextDate.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24);

          // Suspicious gaps (criminal: > 1 day, civil: > 30 days)
          const threshold = practiceArea === "criminal" ? 1 : 30;
          if (daysDiff > threshold) {
            issues.push({
              type: "SUSPICIOUS_GAP",
              description: `${daysDiff.toFixed(0)} days between ${current.label || "event"} and ${next.label || "event"}`,
              attackStrategy: practiceArea === "criminal" 
                ? "Opportunity to dispose of evidence, no immediate link"
                : "Delay suggests weak case or procedural issues",
              readyToUseArgument: practiceArea === "criminal"
                ? `The ${daysDiff.toFixed(0)}-day gap between events creates reasonable doubt about the connection`
                : `The ${daysDiff.toFixed(0)}-day delay suggests the case lacks urgency and strength`,
            });
          }
        }
      }
    }

    // Check for inconsistencies in dates
    const dates = timeline.map((t: any) => t.date).filter(Boolean);
    if (dates.length > 1) {
      // Check if dates are out of order
      const sortedDates = [...dates].sort();
      if (JSON.stringify(dates) !== JSON.stringify(sortedDates)) {
        issues.push({
          type: "INCONSISTENCY",
          description: "Timeline events are out of chronological order",
          attackStrategy: "Timeline is unreliable, undermines case credibility",
          readyToUseArgument: "The timeline is inconsistent, which undermines the reliability of the entire case",
        });
      }
    }

    // Criminal-specific: Check for arrest delays
    if (practiceArea === "criminal" && strategyData) {
      const angles = strategyData.criticalAngles || [];
      const delayIssues = angles.filter((a: any) => 
        a.title?.toLowerCase().includes("delay") || 
        a.title?.toLowerCase().includes("time")
      );
      
      if (delayIssues.length > 0) {
        issues.push({
          type: "PROCEDURAL_DELAY",
          description: delayIssues[0].prosecutionWeakness || "Procedural delay identified",
          attackStrategy: delayIssues[0].howToExploit || "Use delay to undermine case",
          readyToUseArgument: delayIssues[0].legalBasis || "The delay creates reasonable doubt",
        });
      }
    }

    // Civil-specific: Check for limitation/response delays
    if (practiceArea !== "criminal" && strategyData) {
      const weaknesses = strategyData.weakSpots || [];
      const delayWeaknesses = weaknesses.filter((w: any) =>
        typeof w === "string" && (w.toLowerCase().includes("delay") || w.toLowerCase().includes("late"))
      );
      
      if (delayWeaknesses.length > 0) {
        issues.push({
          type: "PROCEDURAL_DELAY",
          description: delayWeaknesses[0],
          attackStrategy: "Use delay to show weak case or procedural failures",
          readyToUseArgument: `The delay in ${delayWeaknesses[0].toLowerCase()} suggests procedural failures`,
        });
      }
    }

    // Missing periods (no account of what happened)
    if (timeline.length > 0) {
      const firstEvent = timeline[0];
      if (firstEvent?.date) {
        const firstDate = new Date(firstEvent.date);
        const now = new Date();
        const totalDays = (now.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24);
        
        if (totalDays > (practiceArea === "criminal" ? 7 : 90)) {
          issues.push({
            type: "MISSING_PERIOD",
            description: `No account of events for ${totalDays.toFixed(0)} days after initial incident`,
            attackStrategy: practiceArea === "criminal"
              ? "Prosecution can't prove defendant was at scene during missing period"
              : "Missing period suggests weak evidence or case preparation",
            readyToUseArgument: practiceArea === "criminal"
              ? "The prosecution cannot account for the defendant's whereabouts during this period"
              : "The missing period suggests the case lacks proper evidence",
          });
        }
      }
    }

    const criticalGaps = issues.filter((i) => 
      i.type === "SUSPICIOUS_GAP" || i.type === "PROCEDURAL_DELAY"
    );

    // Exploitation plan
    const exploitationPlan: string[] = [];
    if (criticalGaps.length > 0) {
      exploitationPlan.push("1. Highlight timeline gaps in opening submissions");
      exploitationPlan.push("2. Use gaps to create reasonable doubt");
      exploitationPlan.push("3. Challenge prosecution's timeline in cross-examination");
    }
    if (issues.some((i) => i.type === "INCONSISTENCY")) {
      exploitationPlan.push("4. Use inconsistencies to undermine case reliability");
    }

    const result: TimelineExploiter = {
      issues,
      criticalGaps,
      exploitationPlan: exploitationPlan.length > 0 ? exploitationPlan : ["Review timeline for exploitation opportunities"],
    };

    return NextResponse.json({ ok: true, data: result });
  } catch (error: any) {
    console.error("[timeline-exploiter] Error:", error);
    return NextResponse.json(
      {
        ok: false,
        error: error.message || "Failed to generate timeline exploiter",
      },
      { status: 500 }
    );
  }
}
